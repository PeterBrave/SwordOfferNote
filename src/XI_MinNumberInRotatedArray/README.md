# 11. 旋转数组的最小数字
 
 > 本节，主要介绍面试常用的查找和排序算法。
 
 查找相对比较简单，主要有顺序查找、二分查找、哈希表查找和二叉排序树查找。
 
 其中最为重要的二分查找，面试时最长考察的算法。
 
 排序相较于查找要复杂一些，要求比较插入排序、冒泡排序、归并排序、快速排序等不同算法的优劣。
 能从额外空间消耗、平均时间复杂度和最差时间复杂度等方面去比较他们的优缺点。
 
 手写快排也是常考的。
 
 ### 手写快排
 
 由于需要使用递归，所以参数列表如下
 ```java
quickSort(int[] arr, int low, int high)
```
第一部分：判断递归终止条件，在`low`大于`high`时递归终止。

第二部分：把`low`的值赋值给`i`，把`high`的值赋值给`j`。
把数组中`low`对应的值赋值给`temp`，即本轮基准值。

第三部分：由于基准值选取的是这一部分数组（索引对应从`low`到`high`的一段）的左边第一个值作为基准，因此通过两个指针`i`与`j`一个在最左侧，一个在最右侧。
右侧的先开始行动，其循环继续的判断条件是`arr[j]>=temp&&i<j`，即`j`的任务是从右往左，找寻比基准值此处是`temp`小的值，因为我们的目的是把小的值换到基准值的左侧。
当右侧找到一个比基准值小的数后，接下来就是左侧的`i`开始行动，`i`的任务是从左往右，找寻比基准值大的数，其循环继续的判断条件是`arr[i]<=temp&&i<j`。整个外层的循环继续条件是`i<j`。
一旦循环条件不满足即`i==j`的情况出现，那么只需要将基准值和`arr[i]`的值交换一个位置，那么这一个基准值的位置就确定完毕。

第四部分： 接下来通过递归的方式，按照基准值，将数组分成两个部分，分别再进行排序。他们的索引分别是`[low,j-1]`,`[j+1, high]`。
至此快速排序算法就写完了。
 
 
 代码写的如下：
 ```java
public void quickSort(int[] arr, int low, int high) {
    int i,j,temp,bm;
    if(low > high) {
        return;
    }
    
    i = low;
    j = high;
    bm = arr[low];
    
    while(i<j) {
        while(arr[j]>=bm&&i<j) {
            j--;
        }
        while(arr[i]<= cbm&&i<j) {
            i++;
        }
        if(i<j) {
            temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    
    arr[low] = arr[i];
    arr[i] = bm;
    
    quickSort(arr, low, i-1);
    quickSort(arr, i+1, high);
}
```
 